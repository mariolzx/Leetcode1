//recursive, time:O(n), space complexity is the complexity of the stack: O(logn)ã€‚

public class FlattenBinaryTreeToLinkedList {
	private TreeNode lastVisit = null;

	public void flatten(TreeNode root) {
		if (root == null) {
			return;
		}
		TreeNode savedRight = root.right;
		if (lastVisit != null) {
			lastVisit.left = null;
			lastVisit.right = root;
		}
		lastVisit = root;
		flatten(root.left);
		flatten(savedRight);
	}
}

//iterative
public class FlattenBinaryTreeToLinkedList {
	public void flatten(TreeNode root) {
		while (root != null) {
			if (root.left != null) {
				TreeNode p = root.left;
				while (p.right != null) {
					p = p.right;
				}
				p.right = root.right;
				root.right = root.left;
				root.left = null;
			}
			root = root.right;
		}
	}
}



Iterative Code: DFS or pre-order traversal

public class Solution {
    public void flatten(TreeNode root) {
        // Start typing your Java solution below
        // DO NOT write main() function
        Stack<TreeNode> toVisit = new Stack<TreeNode>();
        if(root==null) return;
        toVisit.push(root);
        TreeNode prev = null;
        while(!toVisit.isEmpty()){
            TreeNode cur = toVisit.pop();
            if(cur.right!=null)
                toVisit.push(cur.right);
            if(cur.left!=null)
                toVisit.push(cur.left);
            if(prev!=null){
                prev.left=null;
                prev.right = cur;
            }
            prev=cur;
        }
    }
}
